---
docname: draft-ietf-anima-rfc8366bis-latest
stand_alone: true
ipr: trust200902
cat: std
updates: 8366, 8995
consensus: 'yes'
pi:
  toc: 'yes'
  symrefs: 'yes'
  sortrefs: 'yes'
  compact: 'yes'
  subcompact: 'no'
  linkmailto: 'no'
  editing: 'no'
  comments: 'yes'
  inline: 'yes'
  rfcedstyle: 'yes'
title: A Voucher Artifact for Bootstrapping Protocols
abbrev: Voucher Artifact
area: Operations
wg: ANIMA Working Group
kw: voucher
author:
- ins: K. Watsen
  name: Kent Watsen
  org: Watsen Networks
  email: kent+ietf@watsen.net
- ins: M. Richardson
  name: Michael C. Richardson
  role: editor
  org: Sandelman Software
  email:
  - mcr+ietf@sandelman.ca
  - https://orcid.org/0000-0002-0773-8388
  uri: http://www.sandelman.ca/
- ins: E. Dijk
  name: Esko Dijk
  org: IoTconsultancy.nl
  email: esko.dijk@iotconsultancy.nl
- ins: M. Pritikin
  name: Max Pritikin
  org: Cisco Systems
  email: pritikin@cisco.com
- ins: T. Eckert
  name: Toerless Eckert
  org: Futurewei Technologies Inc.
  street: 2330 Central Expy
  city: Santa Clara
  code: '95050'
  country: United States of America
  email: tte@cs.fau.de
- ins: Q. Ma
  name: Qiufang Ma
  org: Huawei
  street: 101 Software Avenue, Yuhua District
  city: Nanjing
  code: '210012'
  country: China
  email: maqiufang1@huawei.com

venue:
  group: anima
  mail: anima@ietf.org
  github: anima-wg/voucher

normative:
  RFC5280:
  RFC5652:
  RFC6020:
  RFC7950:
  RFC8259:
  RFC9254:
  CBOR: STD94
  CORESID: RFC9595
  cBRSKI: I-D.ietf-anima-constrained-voucher
  jBRSKI: I-D.ietf-anima-jws-voucher
  ITU-T.X690.2015:
    target: https://www.itu.int/rec/T-REC-X.690/
    title: 'Information Technology - ASN.1 encoding rules: Specification of Basic
      Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding
      Rules (DER)'
    author:
    - org: International Telecommunication Union
    date: 2015-08
    seriesinfo:
      ITU-T Recommendation X.690,: ISO/IEC 8825-1
  ZERO-TOUCH: RFC8572
  BRSKI: RFC8995
  PRM: I-D.ietf-anima-brski-prm
  CLOUD: I-D.ietf-anima-brski-cloud
  IDEVID:
    target: https://1.ieee802.org/security/802-1ar/
    title: IEEE 802.1AR Secure Device Identifier
    author:
    - org: IEEE Standard
    date: 2018
  RFC8791:

informative:
  RFC3688:
  RFC8446:
  RFC6125:
  RFC6241:
  RFC7435:
  RFC8040:
  RFC8340:
  RFC8366:
  RFC8792:
  RFC9525:
  COSE: STD96
  JWS: RFC7515
  SECUREJOIN: I-D.ietf-6tisch-dtsecurity-zerotouch-join
  YANG-GUIDE: RFC8407
  Stajano99theresurrecting:
    target: https://www.cl.cam.ac.uk/research/dtg/www/files/publications/public/files/tr.1999.2.pdf
    title: 'The Resurrecting Duckling: Security Issues for Ad-Hoc Wireless Networks'
    author:
    - name: Frank Stajano
    - name: Ross Anderson
    date: 1999
  imprinting:
    target: https://en.wikipedia.org/w/index.php?title=Imprinting_(psychology)&oldid=1314466188
    title: 'Wikipedia article: Imprinting (psychology)'
    author:
    - org: Wikipedia
    date: 2025-10-01
  fairhair:
    target: "https://openconnectivity.org/developer/specifications/fairhair/"
    title: 'Fairhair Specification'
    author:
    - org: Open Connectivity Foundation
    date: 2019-11-01

--- abstract


This document defines a strategy to securely assign a Pledge to an Owner
using an artifact signed, directly or indirectly, by the Pledge's manufacturer.
This artifact is known as a "Voucher".

This document defines an artifact format as a YANG-defined JSON or CBOR document
that has been signed using a variety of cryptographic systems.

The Voucher Artifact is normally generated by
the Pledge's manufacturer (i.e., the Manufacturer Authorized Signing
Authority (MASA)).

This document updates RFC8366: it includes a number of desired extensions into the YANG module.
The Voucher Request YANG module defined in RFC8995 is also updated and now included in this document, as well as other YANG extensions needed for variants of BRSKI/RFC8995.

--- middle

# Introduction {#introduction}

This document defines a strategy to securely assign a candidate device
(Pledge) to an Owner using an artifact signed, directly or indirectly,
by the Pledge's manufacturer, i.e., the Manufacturer Authorized
Signing Authority (MASA).  This artifact is known as the "Voucher".

The Voucher Artifact is a JSON {{RFC8259}} document that
conforms with a data model described by YANG {{RFC7950}}.
It may also be serialized to CBOR {{CBOR}}.
It is encoded using the rules defined in {{!RFC7951}} or {{RFC9254}}, and
is signed using (by default) a CMS structure {{RFC5652}}.

The primary purpose of a Voucher is to securely convey a trust anchor
that a Pledge can use to authenticate subsequent interactions.
The trust anchor may be in the form of a certificate (the '`pinned-domain-cert`' Attribute), a hash of a certificate, or it can be a raw public key (in constrained use cases).

This trust anchor represents the authority of the Owner of a network.
Communicating this trust anchor securely to the Pledge is the job of the Voucher Artifact.
The act of communicating this trust anchor is known as pinning the trust anchor, as the Pledge can then use the resulting anchor to authenticate other actors who are part of the network.
The collection of all these actors is collectively known as the Domain.
(This is not related to the domain name system, but rather the term is of mathematical origin)

A Voucher may be useful in several contexts, but the driving motivation herein is to support secure Onboarding mechanisms.
This is accomplished by assigning an Owner to the Pledge, enabling it to authenticate the network that it is connected to.

{{RFC8366}} originally defined the Voucher as the only Voucher Artifact, leaving the Voucher Request that is used in BRSKI to be defined in {{BRSKI}}.
This document includes both Voucher and Voucher Request, and therefore updates {{BRSKI}}.

YANG is not easily extended except by updating the YANG module definition.
Since {{RFC8366}} was written, the common pattern is to publish YANG modules as two documents: one with only the YANG module, and the other one with usage, motivation and further explanation.
This allows the YANG module to be updated without replacing all of the context.
This document does not follow that pattern, but future documents may update only the YANG module.

This document introduces a mechanism to support future extensions without requiring the YANG module to be revised.
This includes both a new IETF standard mechanism for extensions modeled after the mechanism present in {{?RFC8520}}, as well as a facility for manufacturer private extensions.

The lifetimes of Vouchers may vary.
In some Onboarding protocols, the Vouchers may include a nonce restricting them to a single use,  whereas the Vouchers in other Onboarding protocols may have an
indicated lifetime.
In order to support long lifetimes, this document recommends using short lifetimes with programmatic renewal, see {{renewal-over-revocation}}.

Some Onboarding protocols using the Voucher Artifact defined in
this document include: {{ZERO-TOUCH}}, {{SECUREJOIN}}, {{BRSKI}} and {{cBRSKI}}.

# Terminology

This document uses and defines the following terms.
They are used in this document and related documents.

(Voucher) Artifact:
: Used throughout this document to represent a Voucher or Voucher Request as instantiated in the form
  of a signed datastructure. The payload of the signed datastructure is called the Voucher Data.

Attribute:
: A single named data element that can be stored in Voucher Data. The element's name and data type are defined by
  one of the YANG models as defined in this document.

Bootstrapping:
: The process where a Pledge obtains cryptographic key material to identify
   and trust future interactions within a specific Domain network. Based on imprinted
   key material provided during the manufacturing process (see: Imprint).
   This term was used in {{RFC8366}}, but has been supplanted by the term Onboarding.

Domain:
: The set of entities or infrastructure under common administrative
  control.
  The goal of the Onboarding protocol is to enable a Pledge to
  join a Domain and obtain domain-specific security credentials.
  This term is not related to "DNS domain" {{?RFC9499}} although a Domain might be associated to a specific DNS domain.

Imprint:
: The process where a device obtains the cryptographic key material to
  identify and trust future interactions generally as part of the manufacturing.
  This term is taken from Konrad Lorenz's work in biology with new ducklings:
  "during a critical period, the duckling would assume that anything
  that looks like a mother duck is in fact their mother"
  {{Stajano99theresurrecting}}. An equivalent for a device is to
  obtain the fingerprint of the manufacturer's root certification authority (root CA)
  certificate. A device that Imprints on an attacker suffers a similar
  fate to a duckling that imprints on a hungry wolf. Imprinting is a
  term from psychology and ethology, as described in {{imprinting}}.

Join Registrar (and Coordinator):
: A representative of the Domain that is configured, perhaps
  autonomically, to decide whether a new device is allowed to join the
  Domain. The administrator of the Domain interfaces with a Join
  Registrar (and Coordinator) to control this process.
  Typically, a Join Registrar is "inside" its Domain. For simplicity,
  this document often refers to this as just "Registrar".

MASA (Manufacturer Authorized Signing Authority):
: The entity that, for the purpose of this document, issues and signs the
  Vouchers for a manufacturer's Pledges and keeps logs of Pledge ownership.
  In some Onboarding protocols, the MASA may have an Internet
  presence and be integral to the Onboarding process, whereas in
  other protocols the MASA may be an offline service that has no
  active role in the Onboarding process.

Malicious Registrar:
: An on-path active attacker that presents itself as a legitimate Registrar.

Onboarding:
: Onboarding describes the process to provide necessary operational data to a Pledge
  and to complete the process of bringing the Pledge into an operational state.
  This data may include configuration data, but specifically deals with application-specific cryptographic
  key material (application-specific security credentials).
  Since {{RFC8366}}, this term has replaced the term Bootstrapping.

Owner:
: The entity that controls the private key of the trust anchor conveyed by the Voucher.
  Typically, the Owner is indicated by the '`pinned-domain-cert`' Attribute.

Pledge:
: The prospective component/device attempting to find and securely join a Domain.
  When shipped or in factory reset mode, it only trusts authorized representatives of the
  manufacturer.

Registrar:
: See Join Registrar. This term is not related to the term DNS Registrar {{?RFC9499}}.

TOFU (Trust on First Use):
: When a Pledge makes no security decisions but rather simply
  trusts the first Domain entity it is contacted by.
  Used similarly to {{RFC7435}}.
  This is also known as the "resurrecting duckling" model {{Stajano99theresurrecting}}.

Voucher:
: A Voucher Artifact, not a Voucher Request, that is a signed statement
  from the MASA service that indicates to a Pledge
  the cryptographic identity of the Domain it should trust.
  When clarity is needed, it may be preceded by the type of the signature, such as CMS, JWS or COSE.

Voucher Data:
: The raw (serialized) representation of the YANG data elements of a Voucher (Request) without any enclosing signature.
  Current serialization formats include JSON and CBOR.

Voucher Request:
: A signed artifact sent from the Pledge to the Registrar, or from the Registrar to the MASA, for Voucher acquisition.
  When clarity is needed, it may be preceded by the type of the signature, such as CMS, JWS or COSE.

Pledge Voucher Request (PVR):
: A signed artifact sent from the Pledge to the Registrar. It is a specific form of Voucher Request.

Registrar Voucher Request (RVR):
: A signed artifact sent from the Registrar to the MASA. It is a specific form of Voucher Request.

# Requirements Language

{::boilerplate bcp14-tagged}


# Survey of Voucher Types

A Voucher is a cryptographically protected statement to the Pledge
authorizing a zero-touch Onboarding with the Join Registrar of the
Domain. The specific information a Voucher provides is influenced by the
Onboarding use case.

The Voucher can convey the following information to
the Join Registrar and to the Pledge:

Assertion Basis:
: Indicates the method that protects
  the Onboarding (this is distinct from the Voucher signature that
  protects the Voucher itself). Methods include
  manufacturer-asserted ownership verification, assured
  logging operations, or reliance on Pledge behavior
  such as secure or measured boot.
  The Join Registrar uses this information to make a determination as to whether to accept the Pledge into the network.
  Only some methods are normatively defined in this
  document. Other methods are left for future work.

Authentication of Join Registrar:
: Indicates how the Pledge
  can authenticate the Join Registrar.  This document defines
  a mechanism to pin the Domain certificate, or a raw public key.
  Pinning a symmetric key, or CN-ID ({{RFC6125}}) or DNS-ID
  information (as defined in {{RFC9525}}) is left for future work.

Anti-Replay Protections:
: Time- or nonce-based
  information to constrain the Voucher to specific time periods or Onboarding
  attempts.


A number of Onboarding scenarios can be met using differing
combinations of this information. All scenarios address the primary
threat of an on-path active attacker (or MiTM) impersonating the Registrar.
If successful, this would gain control over the Pledge.
The following combinations are "types" of Vouchers:

| Voucher Type        | Assertion |          | Registrar ID |                | Validity |       |
|                     | Logged    | Verified | Trust Anchor | CN-ID or DNS-ID| RTC      | Nonce |
|:--------------------|----------:|---------:|-------------:|---------------:|---------:|------:|
| Audit Voucher       | X         |          | X            |                |          | X     |
|--
| Nonceless Audit     | X         |          | X            |                | X        |       |
|--
| Owner Audit         | X         | X        | X            |                | X        | X     |
|--
| Owner ID Voucher    |           | X        | X            | X              | X        |       |
|--
| Bearer Voucher      | X         |          | wildcard     | wildcard       | optional | opt   |
|==
{: #voucher-types-table title='Overview of Voucher types'}

NOTE: The "RTC" column denotes Voucher validation using a Real-Time Clock.

NOTE: All Voucher types include a "Pledge ID `serial-number`" (column not shown for space reasons).

Audit Voucher:
: An audit Voucher is named after the logging assertion mechanisms
  that the Registrar then "audits" to enforce its local policy. The
  Registrar mitigates the risk of a Malicious Registrar by auditing that no unknown Registrar, or
  known Malicious Registrar, appears in the MASA's log entries for the Pledge.
  This does not directly prevent a Malicious Registrar but provides a response mechanism that
  ensures the on-path attack is unsuccessful.
  An advantage is that actual ownership knowledge (i.e., sales integration providing an indication of who purchased the device) is not required on the MASA service.

Nonceless Audit Voucher:
: An audit Voucher with a validity period statement, but no guarantee of freshness. Fundamentally,
  it is the same as an audit Voucher except that it can be issued in
  advance to support network partitions or to provide a permanent
  Voucher for remote deployments.
  Being issued in advance of the Pledge being online, the Pledge can not rely on a nonce to be included for freshness.
  This compromise in reducing the freshness allows for the resulting Voucher to be carried across air-gapped infrastructure.
  In addition, if the validity period has been set sufficiently long, the Voucher can be used after the manufacturer (and its delegates) has gone out of business.

Ownership Audit Voucher:
: An audit Voucher where the MASA service has verified the Registrar
  as the authorized Owner.
  The MASA service mitigates a MiTM Registrar by refusing to generate
  audit Vouchers for unauthorized Registrars. The Registrar uses audit
  techniques to supplement the MASA. This provides an ideal sharing of
  policy decisions and enforcement between the vendor and the Owner.

Ownership ID Voucher:
: Named after inclusion of the Pledge's CN-ID or DNS-ID within the
  Voucher. The MASA service mitigates a MiTM Registrar by identifying
  the specific Registrar (via PKIX {{RFC5280}}) authorized to own the Pledge.

Bearer Voucher:
: A bearer Voucher is named after the inclusion of a Registrar ID
  wildcard. Because the Registrar identity is not indicated, this
  Voucher type must be treated as a secret and protected from exposure
  as any 'bearer' of the Voucher can claim the Pledge.
  This variation is included in the above table in order to clearly
  show how other Voucher types differ.
  This specification does not support bearer Vouchers at this time.
  There are other specifications in the industry which are equivalent though.
  Publishing a nonceless bearer Voucher effectively turns the
  specified Pledge into a TOFU device with minimal mitigation
  against MiTM Registrars. Bearer Vouchers are therefore out of scope.

# Changes since RFC8366

## Attempts and motivation to extend RFC8366 {#extendfail}

{{RFC8366}} was published in 2018 during the development of {{BRSKI}},
{{ZERO-TOUCH}} and other work-in-progress efforts.
Since then the industry has matured significantly, and the in-the-field activity which this document supports has become known as _Onboarding_ rather than _Bootstrapping_.

The focus of {{BRSKI}} was Onboarding of ISP and Enterprise owned wired routing and switching equipment, with IoT devices being a less important aspect.
{{ZERO-TOUCH}} has focused upon Onboarding of CPE equipment like cable modems and other larger IoT devices, again with smaller IoT devices being of lesser importance.

Since {{BRSKI}} was published there is now a mature effort to do application-level Onboarding of constrained IoT devices defined by the Thread Group and the Fairhair Alliance (now OCF) {{fairhair}}.
The {{cBRSKI}} document has defined a version of {{BRSKI}} that is usable over constrained IEEE 802.15.4 6LoWPAN networks using CoAP and DTLS, while {{?I-D.ietf-lake-authz}} provides for using CoAP and EDHOC on even more constrained devices with very constrained networks.

{{PRM}} has created a new methodology for Onboarding that does not depend upon a synchronous connection between the Pledge and the Registrar.
This mechanism uses a mobile Registrar agent that works to collect and transfer signed artifacts via physical travel from one network to another.

Both {{cBRSKI}} and {{PRM}} require extensions to the Voucher Request and the resulting Voucher. The new Attributes are required to carry the additional data and describe the extended semantics.
In addition {{cBRSKI}} uses the serialization mechanism described in {{RFC9254}} to produce significantly more compact artifacts.

When the process to define {{cBRSKI}} and {{PRM}} was started, there was a belief that the appropriate process was to use the {{RFC7950}} _augment_ mechanism to further extend both the Voucher Request {{BRSKI}} and Voucher {{RFC8366}} artifacts.
However, {{PRM}} needs to extend an enumerated type with additional values and _augment_ can not do this, so that was initially the impetus for this document.

An attempt was then made to determine what would happen if one wanted to have a constrained version of the {{PRM}} Voucher Artifact.
The result was invalid YANG, with multiple definitions of the core Attributes from the {{RFC8366}} Voucher Artifact.
After some discussion, it was determined that the _augment_ mechanism did not work for this use case,
nor did it work better when the {{RFC8040}} "yang-data" extension was replaced with the {{RFC8791}} "structure" extension.

After significant discussion the decision was made to simply roll all of the needed extensions  into this document.

## Informational Model changes since RFC8366

This document therefore represents a merge of YANG definitions from {{RFC8366}}, the Voucher Request from {{BRSKI}}, and extensions to each of these from {{cBRSKI}}, {{CLOUD}} and {{PRM}}.
The difficulty with this approach is that the semantics of the definitions needed for the other documents is not included in this document, but rather in the respective other documents.

# Signature mechanisms

Three signature systems have been defined for Vouchers Artifacts.

{{cBRSKI}} defines a mechanism that uses COSE {{COSE}}, with the Voucher Data encoded using {{RFC9254}}.
However, as the SID {{RFC9254}} allocation process requires up-to-date YANG, the SID values for this mechanism are presented in this document.

{{jBRSKI}} defines a mechanism that uses JSON {{RFC8259}} and {{JWS}}.

The CMS signing mechanism first defined in {{RFC8366}} continues to be defined here.

## CMS Format Voucher Artifact {#cms-voucher}

The IETF evolution of PKCS#7 is CMS {{RFC5652}}.
A CMS-signed Voucher, the default type, contains a ContentInfo
structure with the Voucher Data.
An OID for JSON-encoded Voucher Data is allocated in {{iana-contenttype}}, and
it is to be placed in the '`eContentType`' field in the ContentInfo.

The signing structure is a CMS SignedData structure, as specified by
Section 5.1 of {{RFC5652}}, encoded using ASN.1 Distinguished Encoding
Rules (DER), as specified in ITU-T X.690 {{ITU-T.X690.2015}}.

{{RFC5652}} mandates that `SignedAttributes` MUST be present when the content type is not '`id-data`'.
This mitigates attacks on CMS as described in {{?I-D.vangeest-lamps-cms-euf-cma-signeddata}}.
Decoders MUST verify that `SignedAttributes` are present.

To facilitate interoperability, {{vcj}} the media type "application/voucher-cms+json" and the filename extension ".vcj" were registered by {{RFC8366}}.

The CMS structure MUST contain a '`signerInfo`' structure, as
described in Section 5.1 of {{RFC5652}}, containing the
signature generated over the content using a private key
trusted by the recipient.
Normally, the recipient is the Pledge and the signer is the MASA.
In the Voucher Request, the signer is the Pledge (in the PVR), or the Registrar (in the RVR).

Note that Section 5.1 of {{RFC5652}} includes a
discussion about how to validate a CMS object, which is really a
PKCS7 object (cmsVersion=1).  Intermediate systems (such as the
Bootstrapping Remote Secure Key Infrastructures {{BRSKI}} Registrar)
that might need to evaluate the Voucher in flight MUST be prepared for
such an older format.
No signaling of the format version is necessary, as the manufacturer knows the capabilities
of the Pledge and will use an appropriate format Voucher for each
Pledge.

The CMS structure SHOULD also contain all of the certificates
leading up to and including the signer's trust anchor certificate
known to the recipient.  The inclusion of the trust anchor is
unusual in many applications, but third parties cannot accurately
audit the transaction without it.

The CMS structure MAY also contain revocation objects for any
intermediate certificate authorities (CAs) between the
Voucher issuer and the trust anchor known to the recipient.
However, the use of CRLs and other validity mechanisms is
discouraged, as the Pledge is unlikely to be able to perform
online checks and is unlikely to have a trusted clock source.
As described below, the use of short-lived Vouchers and/or a
Pledge-provided nonce provides a freshness guarantee.

# Voucher Artifact {#voucher}

The Voucher's primary purpose is to securely assign a Pledge to an
Owner.
The Voucher informs the Pledge which entity it should consider to be
its Owner.

This document defines a Voucher Artifact that is a CMS-signed encoding of the
JSON-encoded Voucher Data as defined by the YANG module {{voucher-yang-module}}.
Also, this document defines Voucher Data that is CBOR-encoded based on the same YANG model.
The CBOR-encoded (signed) Voucher based on this CBOR Voucher Data is defined in {{cBRSKI}}.

The Voucher Data format is described here as a practical basis for some uses (such
as in NETCONF), but more to clearly indicate what Vouchers look like
in practice.
This description also serves to validate the YANG data model.

{{RFC8366}} defined a media type and a filename extension for the
CMS-encoded JSON type.
The media type for JOSE format Vouchers is defined in {{jBRSKI}} and the media type for COSE format Vouchers is defined in {{cBRSKI}}.
Both include respective filename extensions.

The media type is used by the Pledge (requesting to the Registrar) and by the Registrar (requesting to the MASA) to signal what Voucher format is expected.
Other aspects of the Voucher, such as it being nonceless or which kind of pinned anchor is used, are not part of the media type.

Only the format of Voucher that is expected is signaled in the form of a (MIME) media
type in the HTTP "Accept" header {{?RFC9110}}.

For Vouchers stored/transferred via methods like a USB storage device (USB key), the Voucher format is usually signaled by a filename extension.

## Tree Diagram {#voucher-tree-diagram}

The following tree diagram illustrates a high-level view of a Voucher
document.
The notation used in this diagram is described in {{RFC8340}}.
Each node in the diagram is fully described by the YANG module in
{{voucher-yang-module}}.
Please review the YANG module for a detailed description of the
Voucher format.

~~~~
{::include-fold yang/ietf-voucher-tree-latest.txt}
~~~~


## Examples {#voucher-examples}

This section provides Voucher Data examples for illustration
purposes.  These examples conform to the JSON encoding rules
defined in {{RFC8259}}.

The following example illustrates an ephemeral Voucher (uses a nonce).
The MASA generated this Voucher using the '`logged`' assertion type, knowing
that it would be suitable for the Pledge making the request.


~~~~
{
  "ietf-voucher:voucher": {
    "created-on": "2016-10-07T19:31:42Z",
    "assertion": "logged",
    "serial-number": "JADA123456789",
    "idevid-issuer": "base64encodedvalue==",
    "pinned-domain-cert": "base64encodedvalue==",
    "nonce": "base64encodedvalue=="
  }
}
~~~~

The following example illustrates a non-ephemeral Voucher (containing no nonce, or "nonceless").
While the Voucher itself expires after two weeks, it presumably can
be renewed for up to a year.   The MASA generated this Voucher
using the '`verified`' assertion type, which should satisfy all Pledges.


~~~~
{
  "ietf-voucher:voucher": {
    "created-on": "2016-10-07T19:31:42Z",
    "expires-on": "2016-10-21T19:31:42Z",
    "assertion": "verified",
    "serial-number": "JADA123456789",
    "idevid-issuer": "base64encodedvalue==",
    "pinned-domain-cert": "base64encodedvalue==",
    "domain-cert-revocation-checks": true,
    "last-renewal-date": "2017-10-07T19:31:42Z"
  }
}
~~~~

The final two examples illustrate a Voucher that includes an (example) extension per {{voucher-ext}}.
The hypothetical YANG module name of the extension is "`example-my-extension`".
First, a JSON serialization is shown.

~~~~
{
  "ietf-voucher:voucher": {
    "created-on": "2016-10-07T19:31:42Z",
    "assertion": "logged",
    "serial-number": "JADA123456789",
    "idevid-issuer": "base64encodedvalue==",
    "pinned-domain-cert": "base64encodedvalue==",
    "nonce": "base64encodedvalue==",
    "extensions": ["example-my-extension"],
    "extension:example-my-extension": {
      "my-ext-leaf1": "my-ext-leaf1-data"
    }
  }
}
~~~~

Next, a CBOR serialization is shown in CBOR diagnostic notation.
This uses again the extension module '`example-my-extension`' and refers to it using its SID value 305823299950.
Note that for this example, long binary strings are abbreviated using the ellipsis (`...`) notation.

~~~~
{
  2451: {                          / ietf-voucher:voucher  /
    2:  "2016-10-07T19:31:42Z",    / created-on            /
    1:  1,                         / assertion (logged)    /
    11: "JADA123456789",           / serial-number         /
    5:  h'04183016 ... 1736C3E0',  / idevid-issuer         /
    8:  h'30820122 ... 12328CFF',  / pinned-domain-cert    /
    7:  h'831D5198A6CA2C7F',       / nonce                 /
    17: [305823299950],            / extensions            /
    47(305823299950): {            / example-my-extension  /
      1: "my-ext-leaf1-data"       / my-ext-leaf1          /
    }
  }
}
~~~~

{{jBRSKI, Section 8}} contains examples of Vouchers encoded in JSON, and signed with {{JWS}}.
{{cBRSKI, Section 9}} contains examples of Vouchers encoded in CBOR, and signed with {{COSE}}.

## YANG Module {#voucher-yang-module}

During development of this merged YANG module, advice was given to better organize mutually exclusive Attributes such as '`pinned-domain-cert`' vs '`pinned-domain-pubk`', or '`expires-on`' vs '`nonce`'.
Unfortunately, {{CORESID}} does not explain how and why choice statements are assigned SID values,
and the tooling as of the end of 2025 is inconsistent with both the document, and the intuitive notions as to how this should work.
As the simplest way forward, the choice mechanisms that were introduced have been commented out in the YANG, allowing the SID values to be generated correctly.
As a result, the SID values presented in {{voucher-sid-values}} and {{voucher-request-sid-values}} are to be considered normative, rather than relying exclusively on the
".sid" file {{CORESID}} generated from the YANG modules.
The presented SID values are believed to be correct, but future reprocessing of the YANG module to a ".sid" file could result in changes as the tooling is fixed.
Any such changes will be recorded as errata on this document.

~~~~ yang
{::include-fold yang/ietf-voucher-latest.yang}
~~~~
{: sourcecode-markers="true" sourcecode-name="ietf-voucher@2025-12-18.yang"}


## ietf-voucher SID values {#voucher-sid-values}

{{RFC9254}} explains how to serialize YANG into CBOR, and for this a series of SID values are required.
The below SID values are assigned to the '`ietf-voucher`' YANG module elements and are considered normative.

The right column shows the XPath expression for the YANG data node to which the SID value is assigned.
In the XPath, the ellipsis (`...`) notation is used to abbreviate the structure path '`/ietf-voucher:voucher`'
to let each entry fit on one line.

~~~~
{::include-fold ietf-voucher-sid.txt}
~~~~

The '`assertion`' Attribute is an enumerated type in {{RFC8366}}, but no values were provided as part of the enumeration.
This document provides enumerated values as part of the YANG module.

In the JSON serialization, the literal strings from the enumerated types are used so there is no ambiguity.

In the CBOR serialization, a small integer is used, and the enumeration values are repeated here for convenience.
However, the YANG module should be considered authoritative.
No IANA registry is provided or necessary because the YANG module (and this document) would be extended when there are new entries required.

CBOR Integer  | Assertion Type
|-|-|
0             | verified
1             | logged
2             | proximity
3             | agent-proximity
{: #assertion-enums title="CBOR integers for the 'assertion' Attribute enum value"}

## Voucher Extensions {#voucher-ext}

An unstated assumption in {{RFC8366}} was that Vouchers could be extended in proprietary ways by manufacturers.
This allows for manufacturers to communicate new things from the MASA to the Pledge, and since both are under control of the same entity, it seemed perfectly fine, even though it would violate the strict definition of the YANG model.

The JSON serialization of Vouchers implicitly accomodates the above, since the Voucher is just a map (or dictionary).
Map keys are just strings, and creating unique strings is easy to do by including the manufacturer's DNS domain name.

In CBOR serialization {{RFC9254}}, the situation is not so easy when SID keys are used.
An extension might need to use "Private range" {{CORESID}} SID values, or acquire SID values for their own use.

Where the process has become complex is when making standard extensions, as has happened recently, resulting in this document.
The processes which were anticipated to be useful (the YANG "augment" mechanism), turned out not to be, see {{extendfail}}.

Instead, a process similar to what was done by {{?RFC8520}} has been adopted.
In the Voucher Data, any extensions are listed in a list Attribute named '`extensions`'.
In JSON serialization, these extensions each require a unique name, and therefore this name MUST be allocated by IANA.
The name MUST be the same as the YANG extension module name.
The '`extensions`' list Attribute allows for new standard extensions to be defined without changes to the '`ietf-voucher`' YANG module.
Items within that list are either strings (in JSON serialization), or integers (in CBOR serialization using SIDs);
both are always defined in the entries of the Voucher Extensions Registry (see {{voucher-ext-reg}}).

Extensions are full YANG modules, which are subject to the SID allocation process described in {{RFC9254}}.
When an extension is serialized, the extension is placed in a sub-map in the value of a new key/value pair in the '`voucher`' container element.
In JSON serialization, the corresponding key is the name of the extension, prefixed by the string "extension:".
In CBOR serialization, the corresponding key is the SID which is allocated as the YANG extension module SID.
This will typically require the absolute SID value Tag(47) to be applied to this key (see {{Section 4.2.1 of RFC9254}}
or the final example in {{voucher-examples}}).

Note that this differs from the mechanism described in {{?RFC8520}}: there, a sub-map is not used.
Instead, keys are created by combining the module name and the Attribute as a string, as a result of using the YANG
"augment" mechanism.
The {{?RFC8520}} mechanism uses more bytes, but is also not easily translatable to CBOR.

As the Voucher Request YANG module is created by YANG augment of the Voucher YANG module, any extension defined for the Voucher is also valid for a Voucher Request.

## Manufacturer Private Extensions

A manufacturer might need to communicate content in the Voucher (or in the Voucher Request), which are never subject to standardization.
While they can use the Voucher extensions mechanism defined in {{voucher-ext}}, it does require allocation of a SID value in order to do minimal-sized encoding in case of CBOR Voucher Data.
Note that {{RFC9254}} does not strictly require use of SIDs: instead of a SID value, the full string name can always
be used. But this would significantly increase the size of the Voucher Data.

Instead, a manufacturer MAY use the '`manufacturer-private`' Attribute to put any content they wish.
In CBOR serialization, if a plain CBOR map would be used, it would be subject to delta encoding: so use of this Attribute requires that the contents are bstr-encoded {{CBOR}} {{RFC8949, Section 3.1}} (Major type 2).
In JSON serialization, delta encoding does not get in the way, and the manufacturer MAY use any encoding that is convenient for them, but base64URL encoding {{?RFC4648, Section 5}} is RECOMMENDED.


# Voucher Request Artifact {#voucher-request}

{{BRSKI, Section 3}} defined a "voucher-request" Artifact as an augmented Artifact from the "voucher" Artifact originally defined in {{RFC8366}}.
That definition has been moved to this document, and translated from the "yang-data" extension {{RFC8040}} to the "sx:structure" extension {{RFC8791}}.

## Tree Diagram {#voucher-request-tree-diagram}

The following tree diagram illustrates a high-level view of a Voucher Request document.
The notation used in this diagram is described in {{RFC8340}}.
Each node in the diagram is fully described by the YANG module in
{{voucher-request-yang-module}}.

~~~~
{::include-fold yang/ietf-voucher-request-tree-latest.txt}
~~~~

## "ietf-voucher-request" Module {#voucher-request-yang-module}
The '`ietf-voucher-request`' YANG module is derived from the '`ietf-voucher`' module.

~~~~ yang
{::include-fold yang/ietf-voucher-request-latest.yang}
~~~~
{: sourcecode-markers="true" sourcecode-name="ietf-voucher-request@2025-12-18.yang"}


## ietf-voucher-request SID values {#voucher-request-sid-values}

{{RFC9254}} explains how to serialize YANG into CBOR, and for this a series of SID values are required.
The below SID values are assigned to the '`ietf-voucher-request`' YANG module elements and are considered normative.

The right column shows the XPath expression for the YANG data node to which the SID value is assigned.
In the XPath, the ellipsis (`...`) notation is used to abbreviate the structure path '`/ietf-voucher-request:voucher`'
to let each entry fit on one line.

~~~~
{::include-fold ietf-voucher-request-sid.txt}
~~~~

The '`assertion`' Attribute is an enumerated type, and has values as defined in {{assertion-enums}}.

# Design Considerations {#design-con}

## Renewals Instead of Revocations {#renewal-over-revocation}

The lifetimes of Vouchers may vary.  In some Onboarding protocols,
the Vouchers may be created and consumed immediately, whereas in other
Onboarding solutions, there may be a significant time delay between
when a Voucher is created and when it is consumed.
In cases when there is a time delay, there is a need for the Pledge
to ensure that the assertions made when the Voucher was created are
still valid.

A revocation artifact is generally used to verify the continued validity
of an assertion such as a PKIX certificate {{RFC5280}}, web token, or Voucher.  With
this approach, a potentially long-lived assertion is paired with a reasonably
fresh revocation status check to ensure that the assertion is still valid.
However, this approach increases solution complexity, as it introduces the
need for additional protocols and code paths to distribute and process the
revocations.

Addressing the shortcomings of revocations, this document recommends
instead the use of lightweight renewals of short-lived non-revocable
Vouchers.  That is, rather than issue a long-lived Voucher, where the
'`expires-on`' Attribute is set to some distant date, the expectation
is for the MASA to instead issue a short-lived Voucher, where the
'`expires-on`' Attribute is set to a relatively near date, along with a promise
(reflected in the '`last-renewal-date`' Attribute) to reissue the Voucher again
when needed.  Importantly, while issuing the initial Voucher may incur
heavyweight verification checks ("Are you who you say you are?" "Does the
Pledge actually belong to you?"), reissuing the Voucher should be a
lightweight process, as it ostensibly only updates the Voucher's
validity period.
With this approach, there is
only the one Artifact, and only one code path is needed to process
it; there is no possibility of a Pledge choosing to skip the
revocation status check because, for instance, the OCSP Responder ({{RFC5280}}) is
not reachable.

While this document recommends issuing short-lived Vouchers, the
Voucher Artifact does not restrict the ability to create long-lived
Vouchers, if required; however, no revocation method is described.

Note that a Voucher may be signed by a chain of intermediate CAs
leading up to the trust anchor CA known by the Pledge.  Even
though the Voucher itself is not revocable, it is still revoked,
per se, if one of the intermediate CA certificates is revoked.

## Voucher Per Pledge

The solution described herein originally enabled a single Voucher to
apply to many Pledges, using lists of regular expressions to represent
ranges of serial numbers.  However, it was determined that blocking the
renewal of a Voucher that applied to many devices would be excessive
when only the ownership for a single Pledge needed to be blocked.
Thus, the Voucher format now only supports a single serial number
to be listed.


# Security Considerations {#sec-con}

## Clock Sensitivity

An attacker could use an expired Voucher to gain control over
a device that has no understanding of time.  The device cannot
trust NTP as a time reference, as an attacker could control
the NTP stream.

There are three things to defend against this: 1) devices are
required to verify that the '`expires-on`' Attribute has not yet passed,
2) devices without access to time can use nonces to
get ephemeral Vouchers, and 3) Vouchers without expiration times
may be used, which will appear in the audit log, informing the
security decision.

This document defines a Voucher format that contains time values
for expirations, which require an accurate clock
in order to be processed correctly.  Vendors planning on
issuing Vouchers with expiration values must ensure that devices
have an accurate clock when shipped from manufacturing
facilities and take steps to prevent clock tampering.
If it is not possible to ensure clock accuracy, then
Vouchers with time values for expirations should not be issued.


## Protect MASA Signing Key in HSM

Pursuant to the recommendation made in Section 6.1 for the MASA to be
deployed as an online Voucher signing service, it is RECOMMENDED that
the MASA's private key used for signing Vouchers is protected by
a hardware security module (HSM).


## Test Domain Certificate Validity When Signing

If a Domain certificate is compromised, then any outstanding
Vouchers for that Domain could be used by the attacker.  In this case, the Domain
administrator is clearly expected to initiate revocation of any
Domain identity certificates (as is normal in PKIX {{RFC5280}} solutions).

Similarly, they are expected to contact the MASA to indicate that
an outstanding (presumably short lifetime) Voucher should be blocked from
automated renewal.
Protocols for Voucher distribution are
RECOMMENDED to check for revocation of Domain identity certificates
before the signing of Vouchers.

## YANG Module Security Considerations

The YANG modules specified in this document define the schema
for data that is subsequently encapsulated by secure signed-data structures,
such as the CMS signed-data described in {{cms-voucher}}.  As such,
all of the YANG-modeled data is protected from modification.

Implementations should be aware that the signed data is only
protected from external modification; the data is still visible.
This potential disclosure of information doesn't affect security
so much as privacy.  In particular, adversaries can glean
information such as which devices belong to which organizations
and which CRL Distribution Point and/or OCSP Responder URLs are
accessed to validate the Vouchers.  When privacy is important,
the CMS signed-data content type SHOULD be encrypted, either by
conveying it via a mutually authenticated secure transport protocol
(e.g., TLS {{RFC8446}}) or by encapsulating the signed-data
content type with an enveloped-data content type (Section 6
of {{RFC5652}}), though details for how to do this are outside
the scope of this document.

The use of YANG to define data structures, via the "sx:structure"
extension {{RFC8791}}, is relatively new and distinct from the traditional use of
YANG to define an API accessed by network management protocols such as
NETCONF {{RFC6241}} and RESTCONF {{RFC8040}}. For this reason, this
security considerations section does not follow the template described
by Section 3.7 of {{YANG-GUIDE}}.


# IANA Considerations {#iana-considerations}

## The IETF XML Registry

This document registers two URIs in the "IETF XML Registry" {{RFC3688}}.

IANA has registered the following:

> {:compact}
>    URI:
>    : urn:ietf:params:xml:ns:yang:ietf-voucher
>
>    Registrant Contact:
>    : The ANIMA WG of the IETF.
>
>    XML:
>    : N/A, the requested URI is an XML namespace.

This reference should be updated to point to this document.

## The YANG Module Names Registry

This document registers two YANG module in the "YANG Module Names"
registry {{RFC6020}}.

IANA has registered the following:

> {:compact}
>   name:
>   : ietf-voucher
>
>   namespace:
>   : urn:ietf:params:xml:ns:yang:ietf-voucher
>
>   prefix:
>   : vch
>
>   reference:
>   : RFC 8366

This reference should be updated to point to this document.

## The Media Types Registry {#vcj}

IANA has registered the media type: `application/voucher-cms+json`, and this registration should be updated to point to this document.

## The SMI Security for S/MIME CMS Content Type Registry {#iana-contenttype}

IANA has registered the OID 1.2.840.113549.1.9.16.1.40, '`id-ct-animaJSONVoucher`'.
This registration should be updated to point to this document.

## The Voucher Extensions Registry {#voucher-ext-reg}

IANA is asked to create a registry of Voucher extensions as follows:

> {:compact}
>   Registry name:
>   : Voucher Extensions Registry
>
>   Registry policy:
>   : First Come First Served
>
>   Reference:
>   : an optional document
>
>   Extension name:
>   : UTF-8-encoded string, not to exceed 40 characters.
>
>   Extension SID:
>   : the YANG module SID value that defines the extension per {{voucher-ext}}.

Each extension MUST follow the rules specified in this specification.
As is usual, the IANA issues early allocations in accordance with {{!RFC7120}}.

Note that the SID module value is allocated as part of a {{CORESID}} process.
This may be from a SID range managed by IANA, or from any other MegaRange.
Future work may allow for PEN based allocations.
IANA does not need to separately allocate a SID value for this column.

Extension name strings for standards track documents are single words, given by the YANG Module Name.
They do not contain dots.
For vendor proprietary extensions, the string SHOULD be made unique by putting the extension name in the form a fully-qualified domain name (FQDN) {{?RFC3696}}, such as "fuubar.example.com"

Vendor proprietary extensions do not need to be registered with IANA, but vendors MAY do so.

Designated Experts should review for standards track documents for clarity, but the process is essentially tied to WG and IESG process:
There are no choices in the extension names (which is always the YANG module name), or SID value (which is from another IANA process).
For non-standards track extensions, the Designated Expert should review whatever document is provided, if any.
The stability of the reference may be of concern.  The Designated Expert should determine if the work overlaps with existing efforts; and if so suggest merging.
However, as registration is optional, the Designated Expert should not block any registrations.

--- back

# Examples

## Key pairs associated with examples

The following Voucher Request has been produced using the IDevID {{IDEVID}} public (certificate) and private key.
They are included so that other developers can match the same output.

The private RSA key:

~~~~
{::include-fold examples/00-D0-E5-F2-00-02.pem}
~~~~

The IDevID certificate (public key):

~~~~
{::include-fold examples/00-D0-E5-F2-00-02.crt}
~~~~

The Certification Authority that created the IDevID:

~~~~
{::include-fold examples/vendor-00-D0-E5-F2-00-02.crt}
~~~~

The private key for the Certification Authority that created the IDevID:

~~~~
{::include-fold examples/vendor-00-D0-E5-F2-00-02.pem}
~~~~

The MASA certificate that signs the Voucher:

~~~~
{::include-fold examples/masa-00-D0-E5-F2-00-02.crt}
~~~~

The private key for MASA certificate signs the Voucher:

~~~~
{::include-fold examples/masa-00-D0-E5-F2-00-02.pem}
~~~~

## Example CMS-signed Voucher Request

~~~~
{::include-fold examples/vr_00-D0-E5-F2-00-02.b64}
~~~~

## Example CMS-signed Voucher from MASA

~~~~
{::include-fold examples/voucher_00-D0-E5-F2-00-02.b64}
~~~~

## Example JWS-signed Voucher from MASA
These examples are folded according to the {{RFC8792}} Single Backslash rule.

~~~~
{
  "payload": "eyJpZXRmLXZvdWNoZXI6dm91Y2hlciI6eyJhc3NlcnRpb24iOiJwcm\
94aW1pdHkiLCJzZXJpYWwtbnVtYmVyIjoiY2FmZmUtOTg3NDUiLCJub25jZSI6IjYyYT\
JlNzY5M2Q4MmZjZGEyNjI0ZGU1OGZiNjcyMmU1IiwiY3JlYXRlZC1vbiI6IjIwMjUtMT\
AtMTVUMDA6MDA6MDBaIiwicGlubmVkLWRvbWFpbi1jZXJ0IjoiTUlJQmd6Q0NBU3FnQX\
dJQkFnSUdBV09XZTBSRk1Bb0dDQ3FHU000OUJBTUNNRFV4RXpBUkJnTlZCQW9NQ2sxNV\
FuVnphVzVsYzNNeERUQUxCZ05WQkFjTUJGTnBkR1V4RHpBTkJnTlZCQU1NQmxSbGMzUk\
RRVEFlRncweE9EQTFNalV3T0RRM016QmFGdzB5T0RBMU1qVXdPRFEzTXpCYU1EVXhFek\
FSQmdOVkJBb01DazE1UW5WemFXNWxjM014RFRBTEJnTlZCQWNNQkZOcGRHVXhEekFOQm\
dOVkJBTU1CbFJsYzNSRFFUQlpNQk1HQnlxR1NNNDlBZ0VHQ0NxR1NNNDlBd0VIQTBJQU\
JIOUVCdXVXVjdJS09ya040YjdsYTVJb2J5dFduV1p3Rm5QdHVsMDlhd3dVSEZQZStOWW\
M1WjVwdUo2ZEFuK0FrVzFnY1poQlhWR0JBM0crSXlSV1VXU2pKakFrTUJJR0ExVWRFd0\
VCL3dRSU1BWUJBZjhDQVFBd0RnWURWUjBQQVFIL0JBUURBZ0lFTUFvR0NDcUdTTTQ5Qk\
FNQ0EwY0FNRVFDSURlWlc2SWZjeUsvLzBBVFk2S21NYjRNMFFJU1FTZFVGVjdQNzlLWV\
ZJWVVBaUJRMVYrd0xSM1Uzd2NJWnhHSE1ISGx0N2M3ZzFDaFdNRVkveEFoU1NZaWlnPT\
0ifX0",
  "signatures": [
    {
      "protected": "eyJ4NWMiOlsiTUlJQmNEQ0I5cUFEQWdFQ0FnUUxod294TUFv\
R0NDcUdTTTQ5QkFNQ01DWXhKREFpQmdOVkJBTU1HMmhwWjJoM1lYa3RkR1Z6ZEM1bGVH\
RnRjR3hsTG1OdmJTQkRRVEFlRncweU1UQTBNVE15TVRRd01UWmFGdzB5TXpBME1UTXlN\
VFF3TVRaYU1DZ3hKakFrQmdOVkJBTU1IV2hwWjJoM1lYa3RkR1Z6ZEM1bGVHRnRjR3hs\
TG1OdmJTQk5RVk5CTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFcWdR\
Vm8wUzU0a1Q0eWZrYkJ4dW1kSE9jSHJwc3FiT3BNS21pTWxuM29CMUhBVzI1TUpWK2dx\
aTR0TUZmU0owaUV3dDhrc3pmV1hLNHJMZ0pTMm1ucGFNUU1BNHdEQVlEVlIwVEFRSC9C\
QUl3QURBS0JnZ3Foa2pPUFFRREFnTnBBREJtQWpFQXJzdGhMZFJjalc2R3Fnc0dIY2JU\
WUxveWN6WWwweU9GU1ljY3pwUWplUnFlUVZVa0hSVWlvVWk3Q3NDclBCTnpBakVBaGp4\
bnM1V2k0dVg1cmZrZG5NRTBNbmoxeityVlJ3T2ZBTC9RV2N0UndwZ0VnU1NLVVJOUXNY\
V3lMNTJvdFBTNSJdLCJ0eXAiOiJ2b3VjaGVyLWp3cytqc29uIiwiYWxnIjoiRVMyNTYi\
fQ",
      "signature": "s_gJM_4qzz1bxDtqh6Ybip42J_0_Y4CMdrMFb8lpPsAhDHVR\
AESNRL3n6M_F8dGQHm1fu66x83cK9E5cPtEdag"
    }
  ]
}
~~~~
{: #ExampleVoucherJWSfigure title="Example JWS Voucher" artwork-align="left"}



# Acknowledgements
{: numbered="no"}

The authors would like to thank the following people for
lively discussions on list and in the halls (ordered
by last name):
{{{William Atwood}}},
{{{Michael H. Behringer}}},
{{{Steffen Fries}}},
{{{Sheng Jiang}}},
{{{Thomas Werner}}}.

{{{Max Pritikin}}} and {{{Kent Watsen}}} were instrumental in creating the original {{RFC8366}}.
