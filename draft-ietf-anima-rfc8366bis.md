---
docname: draft-ietf-anima-rfc8366bis-latest
stand_alone: true
ipr: trust200902
cat: std
consensus: 'yes'
pi:
  toc: 'yes'
  symrefs: 'yes'
  sortrefs: 'yes'
  compact: 'yes'
  subcompact: 'no'
  linkmailto: 'no'
  editing: 'no'
  comments: 'yes'
  inline: 'yes'
  rfcedstyle: 'yes'
title: A Voucher Artifact for Bootstrapping Protocols
abbrev: Voucher Artifact
area: Operations
wg: ANIMA Working Group
kw: voucher
author:
- ins: K. Watsen
  name: Kent Watsen
  org: Watsen Networks
  email: kent+ietf@watsen.net
- ins: M. Richardson
  name: Michael C. Richardson
  org: Sandelman Software
  email: mcr+ietf@sandelman.ca
  uri: http://www.sandelman.ca/
- ins: M. Pritikin
  name: Max Pritikin
  org: Cisco Systems
  email: pritikin@cisco.com
- ins: T. Eckert
  name: Toerless Eckert
  org: Futurewei Technologies Inc.
  street: 2330 Central Expy
  city: Santa Clara
  code: '95050'
  country: United States of America
  email: tte@cs.fau.de
- ins: Q. Ma
  name: Qiufang Ma
  org: Huawei
  street: 101 Software Avenue, Yuhua District
  city: Nanjing
  code: '210012'
  country: China
  email: maqiufang1@huawei.com

venue:
  group: anima
  mail: anima@ietf.org
  github: anima-wg/voucher

normative:
  RFC5652:
  RFC6020:
  RFC8259:
  RFC7950:
  CORESID: RFC9595
  RFC9148:
  cBRSKI: I-D.ietf-anima-constrained-voucher
  jBRSKI: I-D.ietf-anima-jws-voucher
  ITU-T.X690.2015:
    target: https://www.itu.int/rec/T-REC-X.690/
    title: 'Information Technology - ASN.1 encoding rules: Specification of Basic
      Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding
      Rules (DER)'
    author:
    - org: International Telecommunication Union
    date: 2015-08
    seriesinfo:
      ITU-T Recommendation X.690,: ISO/IEC 8825-1
  ZERO-TOUCH: RFC8572
  BRSKI: RFC8995
  PRM: I-D.ietf-anima-brski-prm
  CLOUD: I-D.ietf-anima-brski-cloud
  RFC8791:
informative:
  RFC5246:
  RFC3688:
  RFC6241:
  RFC8040:
  RFC8340:
  RFC6125:
  RFC7435:
  RFC8366:
  CBOR: STD94
  COSE: STD96
  JWS: RFC7515
  YANGCBOR: RFC9254
  SECUREJOIN: I-D.ietf-6tisch-dtsecurity-secure-join
  YANG-GUIDE: RFC8407
  Stajano99theresurrecting:
    target: https://www.cl.cam.ac.uk/research/dtg/www/files/publications/public/files/tr.1999.2.pdf
    title: 'The Resurrecting Duckling: Security Issues for Ad-Hoc Wireless Networks'
    author:
    - name: Frank Stajano
    - name: Ross Anderson
    date: 1999
  imprinting:
    target: https://en.wikipedia.org/w/index.php?title=Imprinting_(psychology)&oldid=825757556
    title: 'Wikipedia article: Imprinting'
    author:
    - org: Wikipedia
    date: 2018-02
  fairhair:
    target: "https://openconnectivity.org/developer/specifications/fairhair/"
    title: 'Fairhair Specification'
    author:
    - org: Open Connectivity Foundation
    date: 2019-11-01

--- abstract


This document defines a strategy to securely assign a Pledge to an owner
using an artifact signed, directly or indirectly, by the Pledge's manufacturer.
This artifact is known as a "voucher".

This document defines an artifact format as a YANG-defined JSON or CBOR document
that has been signed using a variety of cryptographic systems.

The voucher artifact is normally generated by
the Pledge's manufacturer (i.e., the Manufacturer Authorized Signing
Authority (MASA)).

This document updates RFC8366, includes a number of desired extensions into the YANG.
The voucher request defined in RFC8995 is also now included in this document, as well as other YANG extensions needed for variants of BRSKI/RFC8995.

--- middle

# Introduction {#introduction}

This document defines a strategy to securely assign a candidate device
(Pledge) to an owner using an artifact signed, directly or indirectly,
by the Pledge's manufacturer, i.e., the Manufacturer Authorized
Signing Authority (MASA).  This artifact is known as the "voucher".

The voucher artifact is a JSON {{RFC8259}} document that
conforms with a data model described by YANG {{RFC7950}}.
It may also be serialized to CBOR {{CBOR}}.
It is encoded using the rules defined in {{!RFC7951}} or {{!RFC9254}}, and
is signed using (by default) a CMS structure {{RFC5652}}.

The primary purpose of a voucher is to securely convey a trust anchor
that a Pledge can use to authenticate subsequent interactions.
The trust anchor may be in the form of a certificate (the "pinned-domain-cert" attribute), a hash of a certificate, or it can be a raw public key (in constrained variations).

This trust anchor represents the authority of the owner of a network.
Communicating this trust anchor securely to the Pledge is the job of the voucher artifact.
The act of communicating this trust anchor is known as pinning the trust anchor, as the Pledge can then use the resulting anchor to authenticate other actors who are part of the network.
The collection of all these actors is collectively known as the network domain.
(This is not related to the domain name system, but rather the term is of mathematical origin)

A voucher may be useful in several contexts, but the driving motivation herein is to support secure onboarding mechanisms.
This is accomplished by assigning an owner to the Pledge, enabling it to authenticate the network that it is connected to.

{{RFC8366}} originally defined just the voucher artifact, leaving the Voucher Request artifiact that is important to BRSKI to be defined in {{BRSKI}}.
This document includes both Voucher and Voucher-Request, and therefore updates {{BRSKI}}.

YANG is not easily extended except by updating the YANG definition.
Since {{RFC8366}} was written, the pattern is to publish YANG modules as two documents: one with only the YANG module, and the other one with usage, motivation and further explanation.
This allows the YANG module to be updated without replacing all of the context.
This document does not follow that pattern, but future updates are may update only the YANG.

This document also introduces an experimental mechanism to support future extensions without requiring the YANG to be replaced.
This includes both new IETF Standard mechanisms, as well as a facility for manufacturer private extensions.

The lifetimes of vouchers may vary.
In some onboarding protocols, the vouchers may include a nonce restricting them to a single use,  whereas the vouchers in other onboarding protocols may have an
indicated lifetime.
In order to support long lifetimes, this document recommends using short lifetimes with programmatic renewal, see {{renewal-over-revocation}}.

Some onboarding protocols using the voucher artifact defined in
this document include: {{ZERO-TOUCH}}, {{SECUREJOIN}}, and {{BRSKI}}.

# Terminology

This document uses the following terms:

(Voucher) Artifact:
: Used throughout to represent the voucher as instantiated in the form
  of a signed structure.

Bootstrapping:
: The process where a Pledge component obtains cryptographic key material to identify
   and trust future interactions within a specific domain network. Based on imprinted
   key material provided during manufacturing process (see imprinting).

Domain:
: The set of entities or infrastructure under common administrative
  control.
  The goal of the onboarding protocol is to enable a Pledge component to
  join a domain and obtain domain specific security credentials.

Imprint:
: The process where a device obtains the cryptographic key material to
  identify and trust future interactions generally as part of the manufacturing.
  This term is taken from Konrad Lorenz's work in biology with new ducklings:
  "during a critical period, the duckling would assume that anything
  that looks like a mother duck is in fact their mother"
  {{Stajano99theresurrecting}}. An equivalent for a device is to
  obtain the fingerprint of the manufacturer's root certification authority (root ca)
  certificate. A device that imprints on an attacker suffers a similar
  fate to a duckling that imprints on a hungry wolf. Imprinting is a
  term from psychology and ethology, as described in {{imprinting}}.

Join Registrar (and Coordinator):
: A representative of the domain that is configured, perhaps
  autonomically, to decide whether a new device is allowed to join the
  domain. The administrator of the domain interfaces with a join
  registrar (and Coordinator) to control this process.
  Typically, a join registrar is "inside" its domain. For simplicity,
  this document often refers to this as just "registrar".

MASA (Manufacturer Authorized Signing Authority):
: The entity that, for the purpose of this document, issues and signs the
  vouchers for a manufacturer's Pledges.
  In some onboarding protocols, the MASA may have an Internet
  presence and be integral to the onboarding process, whereas in
  other protocols the MASA may be an offline service that has no
  active role in the onboarding process.

malicious registrar:
: An on-path active attacker that presents itself as a legitimate registrar, but which is in fact under the control of an attacker.

Onboarding:
: Onboarding describes the process to provide necessary operational data to Pledge
  components and completes the process to bring a device into an operational state.
  This data may be configuration data, or also application specific cryptographic
  key material (application speciifc security credentials).

Owner:
: The entity that controls the private key of the "pinned-domain-cert"
  certificate conveyed by the voucher.

Pledge:
: The prospective component attempting to find and securely join a
  domain.
  When shipped or in factory reset mode, it only trusts authorized representatives of the
  manufacturer.

Registrar:
: See join registrar.

TOFU (Trust on First Use):
: Where a Pledge component makes no security decisions but rather simply
  trusts the first domain entity it is contacted by.
  Used similarly to {{RFC7435}}.
  This is also known as the "resurrecting duckling" model.

Voucher:
: A short form for Voucher Artifact.  It refers to the signed statement
  from the MASA service that indicates to a Pledge
  the cryptographic identity of the domain it should trust.
  When clarity is needed, it may be preceeded by the type of the signature, such as CMS, JWS or COSE.

Voucher Data:
: The raw (serialized) representation of the YANG without any enclosing signature.
Current formats include JSON and CBOR.

Voucher Request:
: A signed artifact sent from the Pledge to the Registrar, or from the Registrar to the MASA for Voucher acquisition.

Pledge Voucher Request (PVR):
: A signed artifact sent from the Pledge to the Registrar. It is a special form of Voucher Request.

Registrar Voucher Request (RVR):
: A signed artifact sent from the Registrar to the MASA. It is a special form of Voucher Request.

# Requirements Language

{::boilerplate bcp14-tagged}


# Survey of Voucher Types

A voucher is a cryptographically protected statement to the Pledge
device authorizing a zero-touch "imprint" on the join registrar of the
domain. The specific information a voucher provides is influenced by the
onboarding use case.

The voucher can impart the following information to
the join registrar and Pledge:

Assertion Basis:
: Indicates the method that protects
  the imprint (this is distinct from the voucher signature that
  protects the voucher itself). This includes
  manufacturer-asserted ownership verification, assured
  logging operations, or reliance on Pledge behavior
  such as secure root of trust
  of measurement. The join registrar uses this information to make a determination as to whether to accept the Pledge intot he network.
  Only some methods are normatively defined in this
  document. Other methods are left for future work.

Authentication of Join Registrar:
: Indicates how the Pledge
  can authenticate the join registrar.  This document defines
  a mechanism to pin the domain certificate, or a raw public key.
  Pinning a symmetric key, or "CN-ID" or "DNS-ID"
  information (as defined in {{RFC6125}}) is left for future work.

Anti-Replay Protections:
: Time- or nonce-based
  information to constrain the voucher to time periods or bootstrap
  attempts.


A number of onboarding scenarios can be met using differing
combinations of this information. All scenarios address the primary
threat of an on-path active attacker (or MiTM) impersonating the registrar.
This would gain control over the Pledge.
The following combinations are "types" of vouchers:

|            | Assertion || Registrar ID || Validity |
Voucher Type |Logged|Verified |Trust Anchor|CN-ID or DNS-ID| RTC | Nonce |
:------------|-----:|--------:|-----------:|--------------:|----:|------:|
Audit        |  X   |         | X          |               |     | X     |
|--
Nonceless Audit|  X |         | X          |               | X   |       |
|--
Owner Audit  |  X   |   X     | X          |               | X   | X     |
|--
Owner ID     |      |   X     | X          |  X            | X   |       |
|--
Bearer voucher| X|       |   wildcard | wildcard      | optional|opt|
|==

NOTE: All voucher types include a 'Pledge ID serial-number'
      (not shown here for space reasons).

Audit Voucher:
: An Audit Voucher is named after the logging assertion mechanisms
  that the registrar then "audits" to enforce local policy. The
  registrar mitigates a malicious registrar by auditing that an unknown
  malicious registrar does not appear in the log entries.
  This does not
  directly prevent a malicious registrar but provides a response mechanism that
  ensures the on-path-attack is unsuccessful.
  An advantage is that actual ownership knowledge (i.e., sales integration providing an indication of who purchased the device) is not required on the MASA service.

Nonceless Audit Voucher:
: An Audit Voucher without a validity period statement. Fundamentally,
  it is the same as an Audit Voucher except that it can be issued in
  advance to support network partitions or to provide a permanent
  voucher for remote deployments.
  Being issued in advance of the Pledge being online, the Pledge can not provide a nonce to be included for freshness.
  This compromise in reducing the freshness allows for the resulting voucher can be carried across air-gapped infrastructure.
  In addition, as there is no end to the validity period, the voucher can be used after the manufacturer (and it's delegates) has gone out of business.

Ownership Audit Voucher:
: An Audit Voucher where the MASA service has verified the registrar
  as the authorized owner.
  The MASA service mitigates a MiTM registrar by refusing to generate
  Audit Vouchers for unauthorized registrars. The registrar uses audit
  techniques to supplement the MASA. This provides an ideal sharing of
  policy decisions and enforcement between the vendor and the owner.

Ownership ID Voucher:
: Named after inclusion of the Pledge's CN-ID or DNS-ID within the
  voucher. The MASA service mitigates a MiTM registrar by identifying
  the specific registrar (via WebPKI) authorized to own the Pledge.

Bearer Voucher:
: A Bearer Voucher is named after the inclusion of a registrar ID
  wildcard. Because the registrar identity is not indicated, this
  voucher type must be treated as a secret and protected from exposure
  as any 'bearer' of the voucher can claim the pledge
  device.  This variation is included in the above description in order to clearly
  how other voucher types differ.
  This specification does not support bearer vouchers at this time.
  There are other specifications in the industry which are equivalent though.
  Publishing a nonceless bearer voucher effectively turns the
  specified pledge into a "TOFU" device with minimal mitigation
  against MiTM registrars. Bearer vouchers are therefore out of scope.

# Changes since RFC8366

## Attempts and motivation to extend RFC8366 {#extendfail}

{{?RFC8366}} was published in 2018 during the development of {{BRSKI}},
{{ZERO-TOUCH}} and other work-in-progress efforts.
Since then the industry has matured significantly, and the in-the-field activity which this document supports has become known as _onboarding_ rather than _bootstrapping_.

The focus of {{BRSKI}} was onboarding of ISP and Enterprise owned wired routing and switching equipment, with IoT devices being a less important aspect.
{{ZERO-TOUCH}} has focused upon onboarding of CPE equipment like cable modems and other larger IoT devices, again with smaller IoT devices being of less import.

Since {{BRSKI}} was published there is now a mature effort to do application-level onboarding of constrained IoT devices defined by The Thread and Fairhair (now OCF) consortia {{fairhair}}.
The {{cBRSKI}} document has defined a version of {{BRSKI}} that is useable over constrained 802.15.4 networks using CoAP and DTLS, while {{?I-D.selander-ace-ake-authz}} provides for using CoAP and EDHOC on even more constrained devices with very constrained networks.

{{PRM}} has created a new methodology for onboarding that does not depend upon a synchronous connection between the Pledge and the Registrar.
This mechanism uses a mobile Registrar Agent that works to collect and transfer signed artifacts via physical travel from one network to another.

Both {{cBRSKI}} and {{PRM}} require extensions to the Voucher Request and the resulting Voucher. The new attribtes are required to carry the additional attributes and describe the extended semantics.
In addition {{cBRSKI}} uses the serialization mechanism described in {{YANGCBOR}} to produce significantly more compact artifacts.

When the process to define {{cBRSKI}} and {{PRM}} was started, there was a belief that the appropriate process was to use the {{?RFC8040}} _augment_ mechanism to further extend both the voucher request {{BRSKI}} and voucher {{RFC8366}} artifacts.
However, {{PRM}} needs to extend an enumerated type with additional values and _augment_ can not do this, so that was initially the impetus for this document.

An attempt was then made to determine what would happen if one wanted to have a constrained version of the {{PRM}} voucher artifact.
The result was invalid YANG, with multiple definitions of the core attributes from the {{RFC8366}} voucher artifact.
After some discussion, it was determined that the _augment_ mechanism did not work, nor did it work better when {{RFC8040}} yang-data was replaced with the {{RFC8791}} structure mechanisms.

After significant discussion the decision was made to simply roll all of the needed extensions  into this document.

## Informational Model changes since RFC8366

This document therefore represents a merge of YANG definitions from {{RFC8366}}, the voucher-request from {{BRSKI}}, and then extensions to each of these from {{cBRSKI}}, {{CLOUD}} and {{PRM}}.
The difficulty with this approach is that the semantics of the definitions needed for the other documents is not included in this document, but rather in the respective other documents.

# Signature mechanisms

Three signature systems have been defined for vouchers and voucher-requests.

{{!cBRSKI}} defines a mechanism that uses COSE {{RFC9052}}, with the voucher data encoded using {{?RFC9254}}.
However, as the SID process requires up-to-date YANG, the SID values for this mechanism are presented in this document.

{{!jBRSKI}} defines a mechanism that uses JSON {{RFC8259}} and {{JWS}}.

The CMS mechanism first defined in {{RFC8366}} continues to be defined here.

## CMS Format Voucher Artifact {#cms-voucher}

The IETF evolution of PKCS#7 is CMS {{RFC5652}}.
A CMS-signed voucher, the default type, contains a ContentInfo
structure with the voucher content. An eContentType of 40
indicates that the content is a JSON-encoded voucher.

The signing structure is a CMS SignedData structure, as specified by
Section 5.1 of {{RFC5652}}, encoded using ASN.1 Distinguished Encoding
Rules (DER), as specified in ITU-T X.690 {{ITU-T.X690.2015}}.

To facilitate interoperability, {{vcj}} the media type "application/voucher-cms+json" and the filename extension ".vcj". were registered by {{RFC8366}}.

The CMS structure MUST contain a 'signerInfo' structure, as
described in Section 5.1 of {{RFC5652}}, containing the
signature generated over the content using a private key
trusted by the recipient.
Normally, the recipient is the Pledge and the signer is the MASA.
In the Voucher Request, the signer is the Pledge, or the Registrar.
Within this document, the signer is assumed to be the MASA.

Note that Section 5.1 of {{RFC5652}} includes a
discussion about how to validate a CMS object, which is really a
PKCS7 object (cmsVersion=1).  Intermediate systems (such the
Bootstrapping Remote Secure Key Infrastructures {{BRSKI}} registrar)
that might need to evaluate the voucher in flight MUST be prepared for
such an older format.
No signaling is necessary, as the manufacturer knows the capabilities
of the Pledge and will use an appropriate format voucher for each
Pledge.

The CMS structure SHOULD also contain all of the certificates
leading up to and including the signer's trust anchor certificate
known to the recipient.  The inclusion of the trust anchor is
unusual in many applications, but third parties cannot accurately
audit the transaction without it.

The CMS structure MAY also contain revocation objects for any
intermediate certificate authorities (CAs) between the
voucher issuer and the trust anchor known to the recipient.
However, the use of CRLs and other validity mechanisms is
discouraged, as the Pledge is unlikely to be able to perform
online checks and is unlikely to have a trusted clock source.
As described below, the use of short-lived vouchers and/or a
Pledge-provided nonce provides a freshness guarantee.

# Voucher Artifact {#voucher}

The voucher's primary purpose is to securely assign a Pledge to an
owner.
The voucher informs the Pledge which entity it should consider to be
its owner.

This document defines a voucher that is JSON-encoded, and CMS signed encoding of the
data defined in the YANG module {{voucher-yang-module}}.

This format is described here as a practical basis for some uses (such
as in NETCONF), but more to clearly indicate what vouchers look like
in practice.
This description also serves to validate the YANG data model.

{{RFC8366}} defined a media type and a filename extension for the
CMS-encoded JSON type.
The media types for JOSE format vouchers is defined in {{jBRSKI}} and the COSE format voucher is defined in {{cBRSKI}}.

The Media Type is used by the Pledge (to the Registrar) and from the Registrar (to the MASA) to signal what format of voucher is expected.
Other aspects of the voucher, such as it being nonce-less or which kind of pinned anchor is used is not part of the Media type.

Only the format of voucher that is expected is signaled in the form of a (MIME)  Media
Content-Type in the HTTP Accept: header.

For vouchers stored/transferred via methods like a USB storage device (USB key), then the voucher format is usually signaled by a filename extension.

## Tree Diagram {#voucher-tree-diagram}

The following tree diagram illustrates a high-level view of a voucher
document.
The notation used in this diagram is described in {{RFC8340}}.
Each node in the diagram is fully described by the YANG module in
{{voucher-yang-module}}.
Please review the YANG module for a detailed description of the
voucher format.

~~~~
{::include-fold yang/ietf-voucher-tree-latest.txt}
~~~~


## Examples {#voucher-examples}

This section provides voucher examples for illustration
purposes.  These examples conform to the encoding rules
defined in {{RFC8259}}.

The following example illustrates an ephemeral voucher (uses a nonce).
The MASA generated this voucher using the 'logged' assertion type, knowing
that it would be suitable for the Pledge making the request.


~~~~
{
  "ietf-voucher:voucher": {
    "created-on": "2016-10-07T19:31:42Z",
    "assertion": "logged",
    "serial-number": "JADA123456789",
    "idevid-issuer": "base64encodedvalue==",
    "pinned-domain-cert": "base64encodedvalue==",
    "nonce": "base64encodedvalue=="
  }
}
~~~~

The following example illustrates a non-ephemeral voucher (no nonce).
While the voucher itself expires after two weeks, it presumably can
be renewed for up to a year.   The MASA generated this voucher
using the 'verified' assertion type, which should satisfy all Pledges.


~~~~
{
  "ietf-voucher:voucher": {
    "created-on": "2016-10-07T19:31:42Z",
    "expires-on": "2016-10-21T19:31:42Z",
    "assertion": "verified",
    "serial-number": "JADA123456789",
    "idevid-issuer": "base64encodedvalue==",
    "pinned-domain-cert": "base64encodedvalue==",
    "domain-cert-revocation-checks": true,
    "last-renewal-date": "2017-10-07T19:31:42Z"
  }
}
~~~~

{{jBRSKI, Section 8}} contains examples of vouchers encoded in JSON, and signed with {{JWS}}.
{{cBRSKI, Section 9}} contains examples of vouchers encoded in CBOR, and signed with {{COSE}}.

## YANG Module {#voucher-yang-module}

~~~~ yang
{::include-fold yang/ietf-voucher-latest.yang}
~~~~
{: sourcecode-markers="true" sourcecode-name="ietf-voucher@2021-07-02.yang”}


## ietf-voucher SID values {#ietf-voucher-sid-values}

{{RFC9148}} explains how to serialize YANG into CBOR, and for this a series of SID values are required.
While {{CORESID}} defines the management process for these values, due to the immaturity  of the tooling around this YANG-SID mechanisms, the following values are considered normative.
It is believed, however, that they will not change.

~~~~
{::include-fold ietf-voucher-sid.txt}
~~~~

The "assertion" attribute is an enumerated type in {{RFC8366}}, but no values were provided as part of the enumeration.
This document provides enumerated values as part of the YANG module.

In the JSON serialization, the literal strings from the enumerated types are used so there is no ambiguity.

In the CBOR serialization, a small integer is used, and the following values are repeated here.
The YANG module should be considered authoritative in the future.
No IANA registry is provided or necessary because the YANG module (and this document) would be extended when there are new entries to make.

Integer  | Assertion Type
|-|-|
0        | verified
1        | logged
2        | proximity
3        | agent-proximity
{: #assertion-enums title='CBOR integers for the "assertion" attribute enum'}

## Voucher Extensions

An unstated assumption in {{RFC8366}} was that vouchers could be extended in proprietary ways by manufacturers.
This allows for manufacturers to communicate new things from the MASA to the Pledge, and since both are under control of the same entity, it seemed perfectly fine, even though it would violate the strict definition of the YANG.

The JSON serialization of vouchers implicitely accomodates the above, since the voucher is just a map (or dictionary).
Map keys are just strings, and creating unique strings is easy to do by including the manufacturer's domain name.

In CBOR serialization {{RFC9148}}/{{RFC9254}}, the situation is not so easy.
The delta encoding for keys requires new keys to use the absolute Tag(47) for new entities.
An extension might need to use the Private Use SID values, or acquire SID values for their own use.

Where the process has become complex is when making standard extensions, as has happened recently, resulting in this document.
The processes which were anticipated to be useful, (the "augment" mechanism) turned out not to be the case, see {{extendfail}}.

Instead, a process similiar to what was done by {{?RFC8520}} has been adopted.
In this, extensions are listed in a leaf named "extensions"
In JSON serialization, these extensions require a unique name, and this MUST be allocated by IANA.
The name MUST be the same as the YANG module name.
The "extensions" list attribute definied in this model allows for new standard extensions to be defined.
Items within that list are strings (in JSON serialization), or integers (in CBOR serialization), as defined by the Voucher Extension Registry.

Extensions are full YANG modules, which are subject to the SID allocation process described in {{RFC9254}}.
When an extension is serialized,  the extension is placed in a sub-map in the value section.
In JSON serialization, the key is the name of the extension, prefixed by the string "extension:"
In CBOR serialization, the key is the SID which is allocated as the module SID.
This will typically require the absolute Tag(47) to be applied to this key.

Note that this differs from the mechanism described in {{?RFC8520}} in that a sub-map is not used.
Instead keys are created by combining the module name and the attribute as a string.
The {{?RFC8520}} mechanism uses more bytes, but is also not translateable easily to CBOR.

As the Voucher Request artifact is created by augment on the voucher artifact, any extension defined for the voucher is also valid for Voucher Requests.

## Manufacturer Private extensions

In addition to the above described extensions mechanism, a manufacturer might need to communicate content in the voucher (or in the voucher-request), which are never subject to standardization.
While they can use the mechanism above, it does require allocation of a SID in order to do minimal sized encoding.  Note that {{RFC9254}} does not require use of SIDs.

Instead, a manufacturer MAY use the manufacturer-private leaf to put any content they wish.
In CBOR serialization, if a map is used, then it will be subject to delta encoding, so use of this leaf requires that the content are bstr-encoded {{RFC8949, Section 3.1}} (Major type 2).
In JSON serialization, delta-encoding does not get in the way, and the manufacturer MAY use any encoding that is convenient for them, but base64URL encoding {{?RFC4648, Section 5}} is RECOMMENDED.


# Voucher Request Artifact {#voucher-request}

{{BRSKI, Section 3}} defined a Voucher-Request Artifact as an augmented artifact from the Voucher Artifact originally defined in {{?RFC8366}}.
That definition has been moved to this document, and translated from YANG-DATA {{RFC8040}} to the SX:STRUCTURE extension {{RFC8791}}.

## Tree Diagram {#voucher-request-tree-diagram}

The following tree diagram illustrates a high-level view of a voucher
request document.
The notation used in this diagram is described in {{RFC8340}}.
Each node in the diagram is fully described by the YANG module in
{{voucher-request-yang-module}}.

~~~~
{::include-fold yang/ietf-voucher-request-tree-latest.txt}
~~~~

## "ietf-voucher-request" Module {#voucher-request-yang-module}
The ietf-voucher-request YANG module is derived from the ietf-voucher module.

~~~~ yang
{::include-fold yang/ietf-voucher-request-latest.yang}
~~~~
{: sourcecode-markers="true" sourcecode-name="ietf-voucher-request@2023-01-10.yang”}


## ietf-voucher-request SID values {#voucher-request-sid-values}

{{RFC9148}} explains how to serialize YANG into CBOR, and for this a series of SID values are required.
While {{CORESID}} defines the management process for these values, due to the immaturity  of the tooling around this YANG-SID mechanisms, the following values are considered normative.
It is believed, however, that they will not change.

~~~~
{::include-fold ietf-voucher-request-sid.txt}
~~~~

The "assertion" attribute is an enumerated type, and has values as defined above in {{assertion-enums}}.

# Design Considerations {#design-con}

## Renewals Instead of Revocations {#renewal-over-revocation}

The lifetimes of vouchers may vary.  In some onboarding protocols,
the vouchers may be created and consumed immediately, whereas in other
onboarding solutions, there may be a significant time delay between
when a voucher is created and when it is consumed.
In cases when there is a time delay, there is a need for the Pledge
to ensure that the assertions made when the voucher was created are
still valid.

A revocation artifact is generally used to verify the continued validity
of an assertion such as a PKIX certificate, web token, or a "voucher".  With
this approach, a potentially long-lived assertion is paired with a reasonably
fresh revocation status check to ensure that the assertion is still valid.
However, this approach increases solution complexity, as it introduces the
need for additional protocols and code paths to distribute and process the
revocations.

Addressing the shortcomings of revocations, this document recommends
instead the use of lightweight renewals of short-lived non-revocable
vouchers.  That is, rather than issue a long-lived voucher, where the
'expires-on' leaf is set to some distant date, the expectation
is for the MASA to instead issue a short-lived voucher, where the
'expires-on' leaf is set to a relatively near date, along with a promise
(reflected in the 'last-renewal-date' field) to reissue the voucher again
when needed.  Importantly, while issuing the initial voucher may incur
heavyweight verification checks ("Are you who you say you are?" "Does the
Pledge actually belong to you?"), reissuing the voucher should be a
lightweight process, as it ostensibly only updates the voucher's
validity period.
With this approach, there is
only the one artifact, and only one code path is needed to process
it; there is no possibility of a Pledge choosing to skip the
revocation status check because, for instance, the OCSP Responder is
not reachable.

While this document recommends issuing short-lived vouchers, the
voucher artifact does not restrict the ability to create long-lived
voucher, if required; however, no revocation method is described.

Note that a voucher may be signed by a chain of intermediate CAs
leading up to the trust anchor certificate known by the Pledge.  Even
though the voucher itself is not revocable, it may still be revoked,
per se, if one of the intermediate CA certificates is revoked.

## Voucher Per Pledge

The solution described herein originally enabled a single voucher to
apply to many Pledges, using lists of regular expressions to represent
ranges of serial-numbers.  However, it was determined that blocking the
renewal of a voucher that applied to many devices would be excessive
when only the ownership for a single Pledge needed to be blocked.
Thus, the voucher format now only supports a single serial-number
to be listed.


# Security Considerations {#sec-con}

## Clock Sensitivity

An attacker could use an expired voucher to gain control over
a device that has no understanding of time.  The device cannot
trust NTP as a time reference, as an attacker could control
the NTP stream.

There are three things to defend against this: 1) devices are
required to verify that the expires-on field has not yet passed,
2) devices without access to time can use nonces to
get ephemeral vouchers, and 3) vouchers without expiration times
may be used, which will appear in the audit log, informing the
security decision.

This document defines a voucher format that contains time values
for expirations, which require an accurate clock
in order to be processed correctly.  Vendors planning on
issuing vouchers with expiration values must ensure that devices
have an accurate clock when shipped from manufacturing
facilities and take steps to prevent clock tampering.
If it is not possible to ensure clock accuracy, then
vouchers with expirations should not be issued.


## Protect Voucher PKI in HSM

Pursuant the recommendation made in Section 6.1 for the MASA to be
deployed as an online voucher signing service, it is RECOMMENDED that
the MASA's private key used for signing vouchers is protected by
a hardware security module (HSM).


## Test Domain Certificate Validity When Signing

If a domain certificate is compromised, then any outstanding
vouchers for that domain could be used by the attacker.  The domain
administrator is clearly expected to initiate revocation of any
domain identity certificates (as is normal in PKI solutions).

Similarly, they are expected to contact the MASA to indicate that
an outstanding (presumably short lifetime) voucher should be blocked from
automated renewal.
Protocols for voucher distribution are
RECOMMENDED to check for revocation of domain identity certificates
before the signing of vouchers.

## YANG Module Security Considerations

The YANG module specified in this document defines the schema
for data that is subsequently encapsulated by a CMS signed-data
content type, as described in Section 5 of {{RFC5652}}.  As such,
all of the YANG modeled data is protected from modification.

Implementations should be aware that the signed data is only
protected from external modification; the data is still visible.
This potential disclosure of information doesn't affect security
so much as privacy.  In particular, adversaries can glean
information such as which devices belong to which organizations
and which CRL Distribution Point and/or OCSP Responder URLs are
accessed to validate the vouchers.  When privacy is important,
the CMS signed-data content type SHOULD be encrypted, either by
conveying it via a mutually authenticated secure transport protocol
(e.g., TLS {{RFC5246}}) or by encapsulating the signed-data
content type with an enveloped-data content type (Section 6
of {{RFC5652}}), though details for how to do this are outside
the scope of this document.

The use of YANG to define data structures, via the 'yang-data'
statement, is relatively new and distinct from the traditional use of
YANG to define an API accessed by network management protocols such as
NETCONF {{RFC6241}} and RESTCONF {{RFC8040}}. For this reason, these
guidelines do not follow template described by Section 3.7 of
{{YANG-GUIDE}}.


# IANA Considerations {#iana-considerations}

## The IETF XML Registry

This document registers two URIs in the "IETF XML Registry" {{RFC3688}}.

IANA has registered the following:

> {:compact}
>    URI:
>    : urn:ietf:params:xml:ns:yang:ietf-voucher
>
>    Registrant Contact:
>    : The ANIMA WG of the IETF.
>
>    XML:
>    : N/A, the requested URI is an XML namespace.

This reference should be updated to point to this document.

## The YANG Module Names Registry

This document registers two YANG module in the "YANG Module Names"
registry {{RFC6020}}.

IANA has registred the following:

> {:compact}
>   name:
>   : ietf-voucher
>
>   namespace:
>   : urn:ietf:params:xml:ns:yang:ietf-voucher
>
>   prefix:
>   : vch
>
>   reference:
>   :RFC 8366

This reference should be updated to point to this document.

## The Media Types Registry {#vcj}

IANA has registered the media type: voucher-cms+json, and this registration should be updated to point to this document.

## The SMI Security for S/MIME CMS Content Type Registry

IANA has registered the OID 1.2.840.113549.1.9.16.1.40, id-ct-animaJSONVoucher.
This registration should be updated to point to this document.

## Extensions Registry

IANA is asked to create a registry of extensions as follows:

      Registry name: Voucher Extensions Registry
      Registry policy: First Come First Served
      Reference: an optional document
      Extension name: UTF-8-encoded string, not to exceed 40 characters.
      Extension SID: the module SID value as allocated

Each extension MUST follow the rules specified in this specification.
As is usual, the IANA issues early allocations in accordance with {{!RFC7120}}.

Note that the SID module value is allocated as part of a {{!RFC9595}} process.
This may be from a SID range managed by IANA, or from any other MegaRange.
Future work may allow for PEN based allocations.
IANA does not need to separately allocate a SID value for this column.

Extension name strings for standards track documents are single words, given by the YANG Module Name.
They do not contain dots.
For vendor proprietary extensions, the string SHOULD be made unique by putting the extension name in the form a FQDN {{?RFC5822}}, such as "fuubar.example.com"

Vendor proprietary extensions do not need to be registered with IANA, but vendors MAY do so.

Designated Experts should review for standards track documents for clarity, but the process is essentially tied to WG and IESG process:
There are no choices in the extension names (which is the YANG module), or SID (which is from another IANA process).
For non-standard track extensions, the Designated Expert should review whatever document is provided, if any.  The stability of the reference may be of concern.  The Desigtnated Expert should determine if the work overlaps existing efforts; and if so suggest merging.
However, as registration is optional, the designated expert should not block any registrations.

--- back

# Examples

## Key pairs associated with examples

The following voucher request has been produced using the IDevID public (certificate) and private key.
They are included so that other developers can match the same output.

The private RSA key:

~~~~
{::include-fold examples/00-D0-E5-F2-00-02.pem}
~~~~

The IDevID certificate (public key):

~~~~
{::include-fold examples/00-D0-E5-F2-00-02.crt}
~~~~

The Certification Authority that created the IDevID:

~~~~
{::include-fold examples/vendor-00-D0-E5-F2-00-02.crt}
~~~~

The private key for the Certification Authority that created the IDevID:

~~~~
{::include-fold examples/vendor-00-D0-E5-F2-00-02.pem}
~~~~

The MASA certificate that signs the voucher:

~~~~
{::include-fold examples/masa-00-D0-E5-F2-00-02.crt}
~~~~

The private key for MASA certificate signs the voucher:

~~~~
{::include-fold examples/masa-00-D0-E5-F2-00-02.pem}
~~~~

## Example CMS signed voucher request

~~~~
{::include-fold examples/vr_00-D0-E5-F2-00-02.b64}
~~~~

## Example CMS signed voucher from MASA

~~~~
{::include-fold examples/voucher_00-D0-E5-F2-00-02.b64}
~~~~

# Acknowledgements
{: numbered="no"}

The authors would like to thank for following for
lively discussions on list and in the halls (ordered
by last name):
{{{William Atwood}}},
{{{Michael H. Behringer}}},
{{{Esko Dijk}}},
{{{Steffen Fries}}},
{{{Sheng Jiang}}},
{{{Thomas Werner}}}.

